'use strict';

var _graphqlRequest = require('graphql-request');

var _ramda = require('ramda');

var _util = require('./util');

var _constants = require('./constants');

var _faultyKeywords = require('./faulty-keywords');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.sourceNodes = (() => {
  var _ref = _asyncToGenerator(function* ({ boundActionCreators, reporter }, { endpoint, token, query }) {
    if (query) {
      const { createNode } = boundActionCreators;

      const clientOptions = {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined
        }
      };

      const client = new _graphqlRequest.GraphQLClient(endpoint, clientOptions);

      const userQueryResult = yield client.request(query);
      // Keywords workaround
      if ((0, _faultyKeywords.checkForFaultyFields)(userQueryResult, _faultyKeywords.faultyKeywords)) {
        reporter.panic(`gatsby-source-graphcms: ${_faultyKeywords.keywordsError}`);
      }
      if (_constants.DEBUG_MODE) {
        const jsonUserQueryResult = JSON.stringify(userQueryResult, undefined, 2);
        console.log(`\ngatsby-source-graphcms: GraphQL query results: ${jsonUserQueryResult}`);
      }
      (0, _ramda.forEachObjIndexed)((0, _util.createNodes)(createNode, reporter), userQueryResult);
    } else {
      reporter.panic(`gatsby-source-graphcms: you need to provide a GraphQL query in the plugin 'query' parameter`);
    }
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();